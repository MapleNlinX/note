# 命令执行

## 原因

-   代码过滤不严格
-   系统漏洞
-   第三方组件（cms）

## 原理

> 💡WEB应用在调用一些系统命令的函数，但是没对用户的输入参数做严格的过滤和判断，攻击者将恶意命令拼接到正常命令中，造成攻击

## 常见函数

-   system函数：用来执行一个外部的应用程序并将相应的执行结果输出
-   Passthru函数：函数可以用来执行一个UNIX系统命令并显示原始的输出
-   Exec函数：用来执行一个外部的应用程序
-   Eval函数：函数会将参数字符串作为PHP程序代码来执行，将php代码保存成字符串的形式，然后传递给eval函数执行

常用连接符：

-   linux
    -   ; 前后命令都执行
    -   & 前面为假也执行后面的命令
    -   && 前面为假直接出错，不执行后面的命令
    -   \| 只执行后面的命令
    -   || 只有当前面执行出错时，执行后面的命令
-   windows
    -   & 前面为假也执行后面的命令
    -   && 前面为假直接出错，不执行后面的命令
    -   |直接执行后面的语句
    -   ||前面为假，执行后面

## 防御

-   不执行外部的应用程序或命令
    -   尽量使用自定义函数或函数库实现外部应用程序或命令的功能。
    -   在执行system、eval等命令执行功能的函数前，要先确定参数内容
-   使用：escapeshellarg函数处理相关参数
    -   escapeshellarg函数会将任何引起参数或命令结束的字符进行转义
-   使用：safe\_mode\_exec\_dir指定可执行的文件路径
    -   将php.ini文件中的safe\_mode\_exec\_dir设置为on，然后将允许执行的文件放入一个目录中，并设用safe\_mode\_exec\_dir指定这个可执行的文件路径。

## 反序列化命令执行

-   serialize：产生一个可存储的值的表示
-   serialize() 方法通过序列化表单值，传及URL编码文本字符串
-   unserialize从已存储的表中创建PHP的值
-   unserialize()用户通过serialize()函数序列化后的对象或数组进行反序列化，并返回原始的对象结构

反序列化中命令执行PHP函数

-   \_construct()：当一个对象创建时被调用
-   \_destruct()：当一个对象销毁时被调用
-   \_toString()：当一个对象被当作一个字符串使用
-   \_sleep()：在对象在被反序了化之前运行
-   \_wakeup()：将在序列化之后立即被调用
